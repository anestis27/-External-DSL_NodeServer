/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.mydsl.validation

import org.eclipse.xtext.validation.Check
import org.xtext.example.mydsl.myDsl.Attribute
import org.xtext.example.mydsl.myDsl.IntType
import org.xtext.example.mydsl.myDsl.MyDslPackage
import org.xtext.example.mydsl.myDsl.StringType
import org.xtext.example.mydsl.myDsl.ArrayType
import java.util.regex.Pattern
import org.xtext.example.mydsl.myDsl.Entity
import java.util.List
import java.util.ArrayList
import org.eclipse.xtext.validation.CheckType
import org.xtext.example.mydsl.myDsl.Verb
/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MyDslValidator extends AbstractMyDslValidator {
	
	@Check(CheckType::FAST)
	def void chechTheServer(Entity ent){
		if(ent.is!==null){
			val List<String> myList = new ArrayList;
			for(a : ent.attributes){
				myList.add(a.name);
				if(a.name=="DOMAIN"){
					checkDOMAIN(a)
				}
				if(a.name=="PORT"){
					checkPORT(a)
				}
				if(a.name=="URL"){
					checkURL(a)
				}
				if(a.name=="amountOfRequests"){
					checkamountOfRequests(a)
				}
			}
			if(!myList.contains("DOMAIN")){
				error("There is no DOMAIN.", MyDslPackage.Literals.ENTITY__NAME);
			}
			if(!myList.contains("PORT")){
				error("There is no no PORT.", MyDslPackage.Literals.ENTITY__NAME);
			}
			if(!myList.contains("URL")){
				error("There is no URL.", MyDslPackage.Literals.ENTITY__NAME);
			}
			if(!myList.contains("amountOfRequests")){
				error("There is no amountOfRequests.", MyDslPackage.Literals.ENTITY__NAME);
			}
		}
	}
	
	def checkDOMAIN(Attribute atr) {
		var domainName = Pattern.compile(
			"^(([a-zA-Z]{1})|([a-zA-Z]{1}[a-zA-Z]{1})|([a-zA-Z]{1}[0-9]{1})|([0-9]{1}[a-zA-Z]{1})|([a-zA-Z0-9][a-zA-Z0-9-_]{1,61}[a-zA-Z0-9]))\\.([a-zA-Z]{2,6}|[a-zA-Z0-9-]{2,30}\\.[a-zA-Z]{2,3})$")
		var domainIP = Pattern.compile("^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$")
		var valueType = atr.value.elementType
		var isStringType = false;
		var istheRightForm = false;
		switch (valueType) {
			StringType: isStringType = true
		}
		switch (valueType) {
			StringType: istheRightForm = domainName.matcher(valueType.value).matches() || domainIP.matcher(valueType.value).matches()
		} 
		if(!isStringType){ 
			error("Problem with the DOMAIN value.", MyDslPackage.Literals.ENTITY__NAME);
		}
		if(!istheRightForm){ 
			 warning("Domain value might be wrong",MyDslPackage.Literals.ENTITY__NAME);
		}
	}
	
	def checkPORT(Attribute atr) {
		var isIntType = false;
		switch (atr.value.elementType) {
			IntType: isIntType = true
		} 
		if(!isIntType){ 
			error("PORT value should be a positive Integer.", MyDslPackage.Literals.ENTITY__NAME);
		}
	}
	
	def checkURL(Attribute atr) {
		var isArrayType = false;
		switch (atr.value.elementType) {
			ArrayType: isArrayType = true
		} 
		if(!isArrayType){ 
			error("URL value should be an Array.", MyDslPackage.Literals.ENTITY__NAME);
		}else{
			val array = atr.value.elementType as ArrayType
			for(a : array.arrayElements){
				switch(a.value){
					StringType: a.value
					default: error("URL's Array's value's should be a String.", MyDslPackage.Literals.ENTITY__NAME)
				}
			}
		}
	}
	
	def checkamountOfRequests(Attribute atr) {
		var isIntType = false;
		switch (atr.value.elementType) {
			IntType: isIntType = true
		} 
		if(!isIntType){ 
			error("AmountOfRequests value should be a positive Integer.", MyDslPackage.Literals.ENTITY__NAME);
		}
	}
	
	@Check
	def checkVerb(Verb v){
		try{
			var i = 0;
			for(i = 0; i <v.rules.get(v.rules.size-1).url.arrayElements.size; i++){
				val array = v.rules.get(v.rules.size-1).url.arrayElements.get(i).value
				switch(array){
					StringType: array.value
					default: error("Return Array of URL should be a String.", MyDslPackage.Literals.VERB__VERB)
				}
			}
		}catch(Exception e){
			new Exception(e.toString)
		}
	}

}
